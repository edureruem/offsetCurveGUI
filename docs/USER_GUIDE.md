# Offset Curve Deformer & Input Curve Optimizer GUI 사용자 가이드

## 1. 시작하기

### 1.1 애플리케이션 실행
```bash
# 프로젝트 디렉토리로 이동
cd offsetCurveGUI

# Python 가상 환경 활성화 (권장)
python -m venv venv
venv\Scripts\activate  # Windows
source venv/bin/activate  # Linux/Mac

# 의존성 설치
pip install -r requirements.txt

# 애플리케이션 실행
python src/main.py
```

### 1.2 메인 화면 구성
애플리케이션을 실행하면 다음과 같은 구성의 메인 화면이 나타납니다:

- **상단**: 애플리케이션 제목 및 메뉴바
- **워크플로우 섹션**: 진행 상황 및 제어 버튼
- **파라미터 설정**: 기본 설정, 고급 옵션, 컨텍스트 인식 도구
- **로그 패널**: 실행 상태 및 오류 메시지

## 2. 기본 워크플로우

### 2.1 워크플로우 단계별 가이드

#### 2.1.1 1단계: Input Curve Loading
**목적**: 벡터 파일에서 커브 데이터 로드

**지원 형식**:
- SVG (Scalable Vector Graphics)
- AI (Adobe Illustrator)
- EPS (Encapsulated PostScript)
- 기타 벡터 형식

**작업 순서**:
1. "파일 열기" 버튼 클릭
2. 지원되는 벡터 파일 선택
3. 파일 로드 완료 확인

**예상 결과**: 커브 데이터가 메모리에 로드되고 분석 준비 완료

#### 2.1.2 2단계: Input Curve Optimization
**목적**: 입력 커브의 품질 향상 및 복잡도 조절

**주요 파라미터**:
- **최적화 수준** (1-10): 높을수록 더 적극적인 최적화
- **목표 포인트 수**: 최적화 후 원하는 포인트 수
- **부드러움 계수** (0.0-1.0): 높을수록 더 부드러운 커브
- **복잡도 감소** (0.0-1.0): 높을수록 더 단순한 커브

**권장 설정**:
- 간단한 커브: 최적화 수준 3-5, 복잡도 감소 0.2-0.4
- 복잡한 커브: 최적화 수준 7-9, 복잡도 감소 0.5-0.7
- 고품질 요구: 부드러움 계수 0.7-0.9

#### 2.1.3 3단계: Offset Curve Generation
**목적**: 원본 커브로부터 오프셋 커브 생성

**주요 파라미터**:
- **오프셋 거리**: 원본 커브로부터의 거리 (양수: 외부, 음수: 내부)
- **알고리즘 선택**:
  - `parallel`: 평행 오프셋 (가장 일반적)
  - `normal`: 법선 방향 오프셋
  - `advanced`: 고급 알고리즘 (복잡한 경우)
- **품질 수준** (1-10): 높을수록 정확하지만 느림
- **모서리 처리**: `round` (둥글게), `miter` (각진), `bevel` (사각)

**권장 설정**:
- 일반적인 용도: parallel 알고리즘, 품질 수준 5-7
- 정밀한 작업: advanced 알고리즘, 품질 수준 8-10
- 모서리 처리: round (부드러운 결과), miter (각진 결과)

#### 2.1.4 4단계: Result Validation
**목적**: 생성된 결과의 품질 검증

**검증 항목**:
- **기하학적 정확성**: 원본과의 일치도
- **시각적 품질**: 렌더링 품질 및 아티팩트
- **성능 메트릭**: 처리 시간 및 메모리 사용량

**검증 결과**:
- ✅ 통과: 모든 검증 항목 만족
- ⚠️ 경고: 일부 항목에서 개선 필요
- ❌ 실패: 심각한 문제 발견

#### 2.1.5 5단계: Export Results
**목적**: 최종 결과를 파일로 내보내기

**출력 형식**:
- **벡터 형식**: SVG, AI, EPS (편집 가능)
- **래스터 형식**: PNG, JPG (고해상도 이미지)

**메타데이터 포함**:
- 처리 파라미터
- 처리 시간
- 품질 점수
- 원본 파일 정보

### 2.2 워크플로우 제어

#### 2.2.1 제어 버튼
- **시작**: 워크플로우 전체 실행
- **다음**: 다음 단계로 진행
- **재설정**: 워크플로우 초기화
- **현재 실행**: 현재 단계만 실행

#### 2.2.2 진행 상황 모니터링
- **진행 표시줄**: 전체 진행률 표시
- **단계별 상태**: 각 단계의 완료 상태
- **실시간 로그**: 현재 실행 중인 작업 정보

## 3. 고급 옵션 설정

### 3.1 Input Curve Optimizer 고급 옵션

#### 3.1.1 곡률 기반 최적화
**곡률 임계값** (0.0-1.0):
- 낮은 값: 곡률 변화가 큰 부분도 보존
- 높은 값: 곡률 변화가 작은 부분은 단순화

**적응형 샘플링**:
- 활성화: 곡률에 따라 샘플링 밀도 자동 조절
- 비활성화: 균등한 샘플링

**특징 보존 수준** (0.0-1.0):
- 높은 값: 원본의 특징적인 부분 보존
- 낮은 값: 전체적으로 단순화

#### 3.1.2 알고리즘 선택
**최적화 알고리즘**:
- `Douglas-Peucker`: 가장 일반적인 알고리즘
- `Ramer-Douglas-Peucker`: 개선된 버전
- `Visvalingam-Whyatt`: 면적 기반 최적화

**수렴 허용 오차** (0.001-0.1):
- 낮은 값: 더 정확한 결과, 느린 처리
- 높은 값: 빠른 처리, 덜 정확한 결과

**최대 반복 횟수** (10-1000):
- 높은 값: 더 나은 최적화, 느린 처리
- 낮은 값: 빠른 처리, 제한된 최적화

### 3.2 Offset Curve Deformer 고급 옵션

#### 3.2.1 오프셋 알고리즘
**오프셋 방법**:
- `parallel`: 평행 오프셋 (가장 안정적)
- `normal`: 법선 방향 오프셋 (자연스러운 결과)
- `advanced`: 고급 알고리즘 (복잡한 경우)

**자기 교차 처리**:
- `detect`: 자기 교차 감지 및 보고
- `resolve`: 자기 교차 자동 해결
- `ignore`: 자기 교차 무시

**모서리 둥글게 처리**:
- `none`: 모서리 보존
- `round`: 둥글게 처리
- `adaptive`: 적응형 처리

#### 3.2.2 품질 설정
**허용 오차** (0.001-0.1):
- 낮은 값: 높은 정확도, 느린 처리
- 높은 값: 빠른 처리, 낮은 정확도

**최대 편차** (0.01-1.0):
- 낮은 값: 원본과 유사한 결과
- 높은 값: 더 자유로운 오프셋

**부드러운 전환**:
- 활성화: 급격한 변화 방지
- 비활성화: 원본 형태 보존

### 3.3 성능 설정

#### 3.3.1 병렬 처리
**병렬 처리 활성화**:
- 활성화: 다중 CPU 코어 활용
- 비활성화: 단일 스레드 처리

**스레드 수** (1-16):
- 권장: CPU 코어 수와 동일
- 높은 값: 메모리 사용량 증가

**청크 크기** (100-10000):
- 작은 값: 메모리 효율적, 느린 처리
- 큰 값: 빠른 처리, 높은 메모리 사용

#### 3.3.2 메모리 관리
**메모리 제한** (MB):
- 권장: 시스템 메모리의 50-70%
- 높은 값: 더 큰 파일 처리 가능

**캐시 크기** (10-1000):
- 작은 값: 메모리 효율적
- 큰 값: 반복 작업 시 빠름

**정리 간격** (초):
- 짧은 간격: 메모리 효율적
- 긴 간격: 성능 향상

## 4. 컨텍스트 인식 도구

### 4.1 커브 특성 분석

#### 4.1.1 기본 특성
**포인트 수 및 밀도**:
- 포인트 수: 커브의 복잡도 지표
- 밀도: 단위 면적당 포인트 수

**바운딩 박스**:
- 너비/높이: 커브의 전체 크기
- 면적: 커브가 차지하는 공간

**전체 길이**: 커브의 실제 길이

#### 4.1.2 고급 특성
**곡률 분포**:
- 평균 곡률: 전체적인 곡률 수준
- 곡률 표준편차: 곡률 변화의 다양성
- 최대/최소 곡률: 극값 지점

**복잡도 지수**:
- 낮은 값: 단순한 커브
- 높은 값: 복잡한 커브

**대칭성 분석**:
- 대칭성 점수: 0.0 (비대칭) ~ 1.0 (완전 대칭)
- 대칭축: 대칭성의 방향

**특징점 식별**:
- 모서리점: 급격한 방향 변화
- 곡률 극값: 곡률이 최대/최소인 지점

### 4.2 자동 설정 제안

#### 4.2.1 최적화 설정 제안
**포인트 수 기반**:
- 적은 포인트 (< 100): 낮은 최적화 수준
- 중간 포인트 (100-500): 중간 최적화 수준
- 많은 포인트 (> 500): 높은 최적화 수준

**곡률 기반**:
- 낮은 곡률: 높은 부드러움 계수
- 높은 곡률: 낮은 부드러움 계수

**복잡도 기반**:
- 단순한 커브: 낮은 복잡도 감소
- 복잡한 커브: 높은 복잡도 감소

#### 4.2.2 오프셋 설정 제안
**커브 크기 기반**:
- 작은 커브: 작은 오프셋 거리
- 큰 커브: 큰 오프셋 거리

**복잡도 기반**:
- 단순한 커브: 낮은 품질 수준
- 복잡한 커브: 높은 품질 수준

**특성 기반**:
- 곡률 변화가 큰 커브: advanced 알고리즘
- 곡률 변화가 작은 커브: parallel 알고리즘

#### 4.2.3 성능 설정 제안
**커브 크기 기반**:
- 작은 커브: 적은 스레드 수
- 큰 커브: 많은 스레드 수

**복잡도 기반**:
- 단순한 커브: 낮은 메모리 제한
- 복잡한 커브: 높은 메모리 제한

## 5. 문제 해결

### 5.1 일반적인 문제

#### 5.1.1 파일 로드 실패
**문제**: 벡터 파일을 로드할 수 없음

**해결 방법**:
1. 파일 형식 확인 (지원되는 형식인지)
2. 파일 손상 여부 확인
3. 파일 권한 확인
4. 다른 파일로 테스트

**예방 방법**:
- 표준 벡터 형식 사용
- 파일 백업 유지
- 정기적인 파일 무결성 검사

#### 5.1.2 메모리 부족 오류
**문제**: "메모리 부족" 오류 발생

**해결 방법**:
1. 메모리 제한 설정 감소
2. 다른 애플리케이션 종료
3. 시스템 재부팅
4. 더 작은 파일로 테스트

**예방 방법**:
- 적절한 메모리 제한 설정
- 대용량 파일 전처리
- 정기적인 메모리 정리

#### 5.1.3 처리 시간이 너무 김
**문제**: 워크플로우 실행이 너무 느림

**해결 방법**:
1. 품질 수준 감소
2. 병렬 처리 활성화
3. 메모리 제한 증가
4. 청크 크기 증가

**예방 방법**:
- 적절한 파라미터 설정
- 정기적인 성능 모니터링
- 하드웨어 업그레이드 고려

### 5.2 품질 관련 문제

#### 5.2.1 결과 품질이 낮음
**문제**: 생성된 결과의 품질이 기대에 못 미침

**해결 방법**:
1. 품질 수준 증가
2. 허용 오차 감소
3. 최대 편차 감소
4. 고급 알고리즘 사용

**예방 방법**:
- 입력 커브 품질 확인
- 적절한 파라미터 설정
- 정기적인 품질 검증

#### 5.2.2 원본과 결과가 너무 다름
**문제**: 최적화/오프셋 후 원본과 결과가 크게 다름

**해결 방법**:
1. 최적화 수준 감소
2. 복잡도 감소 감소
3. 특징 보존 수준 증가
4. 오프셋 거리 감소

**예방 방법**:
- 보수적인 파라미터 설정
- 단계별 결과 확인
- 정기적인 품질 검증

### 5.3 성능 관련 문제

#### 5.3.1 UI 응답성 저하
**문제**: GUI가 느리게 반응하거나 멈춤

**해결 방법**:
1. 비동기 처리 활성화
2. 업데이트 간격 증가
3. 메모리 정리 실행
4. 애플리케이션 재시작

**예방 방법**:
- 적절한 성능 설정
- 정기적인 메모리 정리
- 시스템 리소스 모니터링

#### 5.3.2 파일 저장 실패
**문제**: 결과 파일 저장이 실패함

**해결 방법**:
1. 저장 경로 권한 확인
2. 디스크 공간 확인
3. 파일명 유효성 확인
4. 다른 형식으로 시도

**예방 방법**:
- 적절한 저장 경로 설정
- 정기적인 디스크 정리
- 백업 시스템 구축

## 6. 최적화 팁

### 6.1 워크플로우 최적화

#### 6.1.1 효율적인 작업 흐름
1. **작은 파일로 테스트**: 큰 파일 전에 작은 파일로 설정 테스트
2. **단계별 실행**: 전체 워크플로우 대신 단계별 실행으로 문제 파악
3. **파라미터 저장**: 성공한 설정을 프리셋으로 저장
4. **배치 처리**: 여러 파일을 순차적으로 처리

#### 6.1.2 파라미터 튜닝
1. **보수적 시작**: 낮은 값으로 시작하여 점진적으로 증가
2. **상호 의존성 고려**: 관련 파라미터 간의 균형 유지
3. **품질 vs 속도**: 작업 요구사항에 맞는 균형점 찾기
4. **정기적 검토**: 결과 품질을 정기적으로 검토하고 조정

### 6.2 성능 최적화

#### 6.2.1 하드웨어 활용
1. **CPU 코어 활용**: 병렬 처리 설정으로 다중 코어 활용
2. **메모리 관리**: 적절한 메모리 제한 설정
3. **디스크 I/O**: SSD 사용으로 파일 입출력 속도 향상
4. **GPU 가속**: 지원되는 경우 GPU 가속 활용

#### 6.2.2 소프트웨어 설정
1. **캐싱 활용**: 반복 작업 시 캐시 크기 증가
2. **청크 처리**: 대용량 데이터의 적절한 청크 크기 설정
3. **백그라운드 처리**: UI 블로킹 방지를 위한 비동기 처리
4. **메모리 정리**: 주기적인 메모리 정리 실행

## 7. 고급 기능

### 7.1 스크립팅 및 자동화

#### 7.1.1 Python API 사용
```python
from src.integratedWorkflow.workflow_manager import WorkflowManager
from ui.main_window import MainWindow

# 워크플로우 매니저 생성
workflow_manager = WorkflowManager()

# 파라미터 설정
workflow_manager.update_step_parameters(1, {
    'optimization_level': 7,
    'target_point_count': 200,
    'smoothness_factor': 0.6
})

# 워크플로우 실행
workflow_manager.start_workflow()
while workflow_manager.workflow_status == "running":
    workflow_manager.execute_current_step()
    workflow_manager.next_step()
```

#### 7.1.2 배치 처리
```python
import os
from pathlib import Path

# 입력 파일 목록
input_files = list(Path("input/").glob("*.svg"))

for input_file in input_files:
    # 워크플로우 실행
    workflow_manager.load_input_file(str(input_file))
    workflow_manager.start_workflow()
    
    # 결과 저장
    output_file = f"output/{input_file.stem}_processed.svg"
    workflow_manager.export_results(output_file)
```

### 7.2 플러그인 개발

#### 7.2.1 커스텀 알고리즘
```python
class CustomOptimizer:
    """커스텀 최적화 알고리즘"""
    
    def __init__(self, parameters: Dict[str, Any]):
        self.parameters = parameters
    
    def optimize(self, curve_data: Dict[str, Any]) -> Dict[str, Any]:
        """커브 최적화 실행"""
        # 커스텀 최적화 로직 구현
        optimized_curve = self._apply_custom_algorithm(curve_data)
        return optimized_curve
    
    def _apply_custom_algorithm(self, curve_data: Dict[str, Any]) -> Dict[str, Any]:
        """실제 최적화 알고리즘"""
        # 여기에 커스텀 알고리즘 구현
        pass
```

#### 7.2.2 플러그인 등록
```python
# 플러그인 매니저에 등록
plugin_manager = PluginManager()
plugin_manager.register_plugin("custom_optimizer", CustomOptimizer)

# 워크플로우에서 사용
workflow_manager.set_optimizer_plugin("custom_optimizer")
```

## 8. 지원 및 문의

### 8.1 도움말 리소스
- **온라인 문서**: 프로젝트 웹사이트의 상세 문서
- **비디오 튜토리얼**: 단계별 사용법 동영상
- **FAQ**: 자주 묻는 질문과 답변
- **커뮤니티 포럼**: 사용자 간 질문과 답변

### 8.2 문제 보고
**버그 리포트 포함 사항**:
1. **시스템 정보**: OS, Python 버전, 애플리케이션 버전
2. **문제 설명**: 발생한 문제의 상세한 설명
3. **재현 단계**: 문제를 재현할 수 있는 단계별 방법
4. **오류 메시지**: 발생한 오류 메시지 전체
5. **로그 파일**: 애플리케이션 로그 파일
6. **입력 파일**: 문제가 발생한 입력 파일 (가능한 경우)

**성능 이슈 보고**:
1. **하드웨어 사양**: CPU, 메모리, 디스크 정보
2. **작업 크기**: 처리한 파일의 크기와 복잡도
3. **파라미터 설정**: 사용한 설정 값들
4. **성능 측정**: 처리 시간, 메모리 사용량 등

### 8.3 기능 요청
**기능 요청 시 포함 사항**:
1. **요청 기능**: 원하는 기능의 상세한 설명
2. **사용 사례**: 해당 기능이 필요한 구체적인 상황
3. **우선순위**: 기능의 중요도와 긴급성
4. **대안 방안**: 현재 가능한 해결 방법

---

이 사용자 가이드는 Offset Curve Deformer & Input Curve Optimizer GUI의 효과적인 사용을 위한 상세한 정보를 제공합니다. 추가 질문이나 도움이 필요한 경우 프로젝트 팀에 문의하시기 바랍니다.
